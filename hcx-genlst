#!/usr/bin/env python3

import sys
import argparse
import itertools
import time
from threading import Thread

parser = argparse.ArgumentParser(description='generate a password wordlist from strings (words)')

parser.add_argument('-s', '--string', metavar='word', action="append", type=str, help="append word to word set for generation (can have multiple -s)")
parser.add_argument('-i', '--input', metavar='infile', type=str, help="append every line in file to word set")
parser.add_argument('-o', '--output', metavar='outfile', type=str, help="file to write to (default: stdout)")
parser.add_argument('-v', '--verbose', action='store_true', help="print status")
parser.add_argument('-l', '--lower', action='store_true', help="add lowercase word variation to word set")
parser.add_argument('-u', '--upper', action='store_true', help="add UPPERCASE word variation to word set")
parser.add_argument('-t', '--title', action='store_true', help="add Title word variation to word set")
parser.add_argument('-r', '--reverse', action='store_true', help="reverse string")
parser.add_argument("-1", '--wordint', action='store_true', help="word + int")
parser.add_argument("-2", '--intword', action='store_true', help="int + word")
parser.add_argument("-3", '--intwordint', action='store_true', help="int + word + int")
parser.add_argument('-y', '--year', action='store_true', help="just generate [0](0-100) and years 1800-2025")
parser.add_argument('-m', '--min', metavar='number', default=8, type=int, help="min password len (default: 8)")
parser.add_argument('-c', '--check', action="store_true", help="check if output is unique, don't generate dupes, slower")
parser.add_argument('-d', '--double', action="store_true", help="double mode -- permutate every word in word set len 2 (<str><str>)")
parser.add_argument('-z', '--double_small', action='store_true', help="double mode -- just do (<str1><str1>)")
parser.add_argument('-j', '--double_join', metavar='string', type=str, default="", help="double mode -- join string (<str><join><str>)")

args = parser.parse_args()

if args.verbose:
    sys.stderr.write(f"{args}\n")

    class Progress:
        def __init__(self, current, total, length=25):
            self.current = current
            self.total = total
            self.length = length
            self.running = True
            self.start_time = time.time()
            self.prev_time = self.start_time
            self.prev_processed = 0

            # Start the thread to display the progress
            self.thread = Thread(target=self.run)
            self.thread.start()

        def run(self):
            while self.running:
                self.display(self.current)
                time.sleep(0.05)

        def display(self, current):
            elapsed_time = time.time() - self.start_time
            time_delta = time.time() - self.prev_time

            if elapsed_time == 0:
                words_per_sec = 0
            else:
                words_per_sec = (current - self.prev_processed) / time_delta

            percent_complete = (current / self.total) * 100
            filled_length = int(self.length * percent_complete // 100)
            bar = '#' * filled_length + '-' * (self.length - filled_length)
            sys.stderr.write(f'\r[{bar}] {percent_complete:.0f}% ({current}/{self.total}) {words_per_sec:.1f} w/s          ')
            sys.stderr.flush()

            self.prev_time = time.time()  # Update the time for the next calculation
            self.prev_processed = current  # Track the last processed word count

        def update(self, current):
            self.current = current

        def stop(self):
            self.running = False
            self.thread.join()
            sys.stderr.write('\n')

        def finish(self):
            self.current = self.total
            self.display(self.current)
            self.stop()

#
# get input
#

words = set()
def add_word(word):
    words.add(word)

# add word variations to list
def word_variations(word):
    add_word(word)
    if args.lower: add_word(word.lower())
    if args.upper: add_word(word.upper())
    if args.title: add_word(word.title())
    if args.reverse: add_word(word[::-1].lower())
    #addword(word[::-1].upper())
    #addword(word[::-1].title())

if args.string:
    for i in args.string:
        word_variations(i)

if args.input:
    if args.verbose:
        sys.stderr.write(f"loading file... ")
        sys.stderr.flush()

    with open(args.input, 'r') as file:
        for line in file:
            word_variations(line.strip())

words_n = len(words)
if args.verbose:
    sys.stderr.write(f"word set length: {words_n}\n")
    sys.stderr.flush()


#
# define output
#
if args.output:
    output_file = open(args.output, "w")
    def write_output(line):
        output_file.write(f"{line}\n")
else:
    def write_output(i):
        print(i)

output_uniq = set()
def output_unique(i):

    if len(i) < args.min:
        return

    if args.check:
        if i in output_uniq:
            return
        output_uniq.add(i)

    write_output(i)

#
# generation
#

def append_num_variations(word, callback):
    suffixes = [
        "!", "!!", "!!!", ".", "..", "...", "@", "@@", "@@@", "#", "12345", "123456",
        "1234567", "12345678", "123456789", "1234567890", "12345678910", "012345",
        "0123456", "01234567", "012345678", "0123456789", "01234567890", "012345678910"
    ]
    for suffix in suffixes:
        callback(word, suffix)
        reversed_suffix = suffix[::-1]
        if reversed_suffix != suffix:
            callback(word, reversed_suffix)
    for i in range(10):
        callback(word, f"00{i}")

    if args.year:
        special_years = ["123", "1234", "31337", "1337", "1312", "3112", "403"]
        for special in special_years:
            callback(word, special)
            reversed_special = special[::-1]
            if reversed_special != special:
                callback(word, reversed_special)
        for year in range(0, 101):
            callback(word, str(year))
            callback(word, f"0{year}")
        for year in range(1800, 2025):
            callback(word, str(year))
    else:
        for num in range(10001):
            callback(word, str(num))
            callback(word, f"0{num}")


def generate_word_variations():
    for word in words:
        output_unique(word)
    if args.verbose:
        progress = Progress(current=1, total=len(words))

    for idx, word in enumerate(words):
        if args.verbose:
            progress.update(idx + 1)
        if args.wordint:
            append_num_variations(word, lambda w, n: output_unique(w + n))
        if args.intword:
            append_num_variations(word, lambda n, w: output_unique(n + w))
        if args.intwordint:
            append_num_variations(word, lambda n, w: output_unique(n + w + n))

    if args.verbose:
        progress.finish()

def generate_double_mode():
    for word in words:
        output_unique(word + args.double_join + word)

    if not args.double_small:
        if args.verbose:
            total_permutations = words_n * (words_n - 1)
            progress = Progress(current=1, total=total_permutations)

        for idx, (word1, word2) in enumerate(itertools.permutations(words, 2)):
            if args.verbose:
                progress.update(idx + 1)
            output_unique(word1 + args.double_join + word2)

        if args.verbose:
            progress.finish()

if args.double:
    generate_double_mode()
else:
    generate_word_variations()

# Close output file if necessary
if args.output:
    output_file.close()

